---
title: 算法—动态规划算法求收花生问题
topic: algorithm
date: 2024-10-16 13:31:34
tags:
- 算法
- 动态规划
categories: 
- 算法

repo: GEM-Jay/hexo-theme-stellar
---
# 动态规划算法求收花生问题

## 算法描述

【问题描述】收获花生问题  
咚咚想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地\(如下图\)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。咚咚只能向东或向南走，不能向西或向北走。问咚咚最多能够摘到多少颗花生。  
![原理图](https://cdn.jsdelivr.net/gh/GEM-Jay/images/shouhuasheng.jpg)

【输入】  
第一行是一个整数T，代表一共有多少组数据。1\<=T \<= 100  
接下来是T组数据。  
每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C \( 1\<= R,C \<=100\)  
每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有 C 个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目 M \( 0\<= M \<= 1000\)。

【输出】  
【样例输入】  
2  
2 2  
1 1  
3 4  
2 3  
2 3 4  
1 6 5  
【样例输出】  
8  
16

对每组输入数据，输出一行，内容为能摘到得最多的花生颗数。

【问题分析】  
根据题意只能向东或者向南走，不能向西或向北走。所以这道题不用判断是不是访问过，直接选取最大的经过的数来代替，然后把最后一个数输出就大功告成了。以下是具体思路图片。

【算法设计】给出算法设计思想，并用动态规划算法实现。

## C语言的实现

```代码
#include<stdio.h>
#define MAX 1000
int w[MAX][MAX];
int f[MAX][MAX];
int t,n,m;

int main(){
	printf("请输入数据组数t的值:");
    scanf("%d",&t);
    while(t--){
		printf("请输入行数n和列数m的值:");
        scanf("%d %d",&n,&m);
		printf("请输入每个节点上的花生数量\n");
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                scanf("%d",&w[i][j]);
        for(i=1;i<=n;i++)
            for(int j=1;j<=m;j++){
				if(f[i-1][j]>f[i][j-1])
					f[i][j] = f[i-1][j]+w[i][j];
				else
					f[i][j] = f[i][j-1]+w[i][j];
			}
			printf("可以摘到的花生的总和的最大值是:%d\n",f[n][m]);
    }
	return 0;
}
```

## 运行截图

![收花生](https://cdn.jsdelivr.net/gh/GEM-Jay/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%B1%82%E6%94%B6%E8%8A%B1%E7%94%9F.jpg)